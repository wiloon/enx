version: '3'

vars:
  APP_NAME: enx-api
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  GIT_COMMIT:
    sh: git rev-parse HEAD 2>/dev/null || echo "unknown"
  GIT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown"
  BUILD_TIME:
    sh: date -u '+%Y-%m-%d_%H:%M:%S_UTC'

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  deps:
    desc: Download Go module dependencies
    cmds:
      - go mod download
      - go mod verify

  tidy:
    desc: Tidy Go module dependencies
    cmds:
      - go mod tidy

  build-dev:
    desc: Build for development (without version injection)
    cmds:
      - echo "Building {{.APP_NAME}} for development..."
      - go build -o {{.APP_NAME}} .
      - echo "Build completed! Binary{{.APP_NAME}}"

  build:
    desc: Build with version information
    cmds:
      - echo "Building {{.APP_NAME}} with version information..."
      - echo "Version{{.VERSION}}"
      - echo "Git Commit{{.GIT_COMMIT}}"
      - echo "Git Branch{{.GIT_BRANCH}}"
      - echo "Build Time{{.BUILD_TIME}}"
      - go build -ldflags "-X enx-server/version.Version={{.VERSION}} -X enx-server/version.GitCommit={{.GIT_COMMIT}} -X enx-server/version.GitBranch={{.GIT_BRANCH}} -X enx-server/version.BuildTime={{.BUILD_TIME}}" -o {{.APP_NAME}} .
      - echo "Build completed successfully!"

  build-version:
    desc: Build with specific version (usage - task build-version VERSION=1.0.0)
    cmds:
      - |
        if [ -z "{{.VERSION}}" ]; then
          echo "Error: VERSION is required"
          echo "Usage: task build-version VERSION=1.0.0"
          exit 1
        fi
      - echo "Building {{.APP_NAME}} with version {{.VERSION}}..."
      - echo "Git Commit{{.GIT_COMMIT}}"
      - echo "Git Branch{{.GIT_BRANCH}}"
      - echo "Build Time{{.BUILD_TIME}}"
      - go build -ldflags "-X enx-server/version.Version={{.VERSION}} -X enx-server/version.GitCommit={{.GIT_COMMIT}} -X enx-server/version.GitBranch={{.GIT_BRANCH}} -X enx-server/version.BuildTime={{.BUILD_TIME}}" -o {{.APP_NAME}} .
      - echo "Build completed with version {{.VERSION}}!"

  run:
    desc: Run the application locally using go run
    cmds:
      - echo "Starting {{.APP_NAME}} in development mode..."
      - go run .

  run-binary:
    desc: Run the built binary
    deps:
      - build-dev
    cmds:
      - echo "Starting {{.APP_NAME}} from binary..."
      - ./{{.APP_NAME}}

  dev:
    desc: Run with hot reload (usage - task dev [MODE=fg|bg] - default is fg)
    vars:
      MODE: '{{.MODE | default "fg"}}'
      LOG_FILE: 'logs/dev.log'
    cmds:
      - |
        GOPATH=$(go env GOPATH)
        export PATH="$GOPATH/bin:$PATH"
        if ! command -v air &> /dev/null; then
          echo "air is not installed. Installing..."
          go install github.com/air-verse/air@latest
        fi
        
        MODE="{{.MODE}}"
        if [ "$MODE" = "bg" ]; then
          echo "üöÄ Starting {{.APP_NAME}} in development mode (background)..."
          mkdir -p logs
          nohup air > {{.LOG_FILE}} 2>&1 &
          echo $! > air.pid
          sleep 2
          if ps -p $(cat air.pid) > /dev/null 2>&1; then
            echo "‚úÖ Development server started (PID: $(cat air.pid))"
            echo "   Logs: {{.LOG_FILE}}"
            echo "   Stop with: task stop or pkill -f air"
          else
            echo "‚ùå Failed to start development server"
            tail -20 {{.LOG_FILE}}
            exit 1
          fi
        elif [ "$MODE" = "fg" ]; then
          echo "üöÄ Starting {{.APP_NAME}} in development mode (foreground)..."
          air
        else
          echo "Error: Invalid MODE '${MODE}'. Use 'fg' or 'bg'"
          exit 1
        fi

  test:
    desc: Run unit tests only (fast, no database)
    cmds:
      - echo "Running unit tests..."
      - go test -short ./...

  test-integration:
    desc: Run integration tests (requires database and config)
    cmds:
      - echo "Setting up integration test environment..."
      - |
        # Create test database if not exists
        if [ ! -f enx.db ]; then
          echo "Creating test database..."
          sqlite3 enx.db < enx.sql
        fi
      - |
        # Create test config if not exists
        if [ ! -f config.toml ]; then
          echo "Using test config..."
          cp config-e2e.toml config.toml
        fi
      - echo "Running integration tests..."
      - go test -tags=integration ./...

  test-all:
    desc: Run all tests (unit + integration)
    cmds:
      - task: test
      - task: test-integration

  test-coverage:
    desc: Run tests with coverage
    cmds:
      - echo "Running tests with coverage..."
      - go test -cover -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated coverage.html"

  test-pkg:
    desc: Run tests for a specific package (usage - task test-pkg PKG=./enx)
    cmds:
      - go test -v {{.PKG}}

  lint:
    desc: Run linters (requires golangci-lint)
    cmds:
      - |
        if ! command -v golangci-lint &> /dev/null; then
          echo "golangci-lint is not installed. Please install it first."
          echo "Install brew install golangci-lint"
          exit 1
        fi
      - golangci-lint run

  fmt:
    desc: Format code
    cmds:
      - go fmt ./...

  vet:
    desc: Run go vet
    cmds:
      - go vet ./...

  clean:
    desc: Clean build artifacts
    cmds:
      - echo "Cleaning build artifacts..."
      - rm -f {{.APP_NAME}}
      - rm -f *.exe
      - rm -f coverage.out coverage.html
      - echo "Clean completed!"

  version:
    desc: Show version information
    cmds:
      - echo "Current version information"
      - echo "Version{{.VERSION}}"
      - echo "Git Commit{{.GIT_COMMIT}}"
      - echo "Git Branch{{.GIT_BRANCH}}"
      - echo "Build Time{{.BUILD_TIME}}"

  check-env:
    desc: Check development environment
    cmds:
      - echo "Checking development environment..."
      - echo "Go version"
      - go version
      - echo ""
      - echo "Go environment"
      - go env GOPATH GOROOT
      - echo ""
      - echo "Configuration file"
      - test -f config.toml && echo "config.toml exists" || echo "config.toml missing"
      - echo ""
      - echo "Dependencies status"
      - go mod verify

  migrate:
    desc: Run database migrations
    cmds:
      - echo "Running database migrations..."
      - go run ./cmd/migrate/main.go

  run-local:
    desc: Complete local setup and run (deps + build + run)
    deps:
      - deps
      - build-dev
    cmds:
      - echo "Starting {{.APP_NAME}}..."
      - ./{{.APP_NAME}}

  start:
    desc: Start API server (usage - task start [MODE=fg|bg] - default is fg)
    deps:
      - build-dev
    vars:
      MODE: '{{.MODE | default "fg"}}'
      PID_FILE: '{{.APP_NAME}}.pid'
      LOG_FILE: '{{.APP_NAME}}.log'
    cmds:
      - |
        MODE="{{.MODE}}"
        if [ "$MODE" = "bg" ]; then
          echo "Starting {{.APP_NAME}} in background mode..."
          nohup ./{{.APP_NAME}} > {{.LOG_FILE}} 2>&1 &
          echo $! > {{.PID_FILE}}
          echo "{{.APP_NAME}} started in background (PID: $(cat {{.PID_FILE}}))"
          echo "Log file: {{.LOG_FILE}}"
          echo "Stop with: task stop"
        elif [ "$MODE" = "fg" ]; then
          echo "Starting {{.APP_NAME}} in foreground mode..."
          ./{{.APP_NAME}}
        else
          echo "Error: Invalid MODE '${MODE}'. Use 'fg' or 'bg'"
          exit 1
        fi

  stop:
    desc: Stop background API server (supports both air and binary modes)
    cmds:
      - |
        STOPPED=0
        
        # Try to stop air process first
        if [ -f air.pid ]; then
          PID=$(cat air.pid)
          if kill -0 $PID 2>/dev/null; then
            echo "üõë Stopping air development server (PID: $PID)..."
            kill $PID
            rm -f air.pid
            echo "‚úÖ air stopped"
            STOPPED=1
          else
            echo "‚ö†Ô∏è  air process $PID not found. Cleaning up PID file..."
            rm -f air.pid
          fi
        fi
        
        # Try to stop binary process
        if [ -f {{.APP_NAME}}.pid ]; then
          PID=$(cat {{.APP_NAME}}.pid)
          if kill -0 $PID 2>/dev/null; then
            echo "üõë Stopping {{.APP_NAME}} (PID: $PID)..."
            kill $PID
            rm -f {{.APP_NAME}}.pid
            echo "‚úÖ {{.APP_NAME}} stopped"
            STOPPED=1
          else
            echo "‚ö†Ô∏è  Process $PID not found. Cleaning up PID file..."
            rm -f {{.APP_NAME}}.pid
          fi
        fi
        
        # Also try to kill any remaining air or enx-api processes
        pkill -f "air.*enx-api" && echo "‚úÖ Killed remaining air processes" || true
        pkill -f "enx-api/tmp/enx-api" && echo "‚úÖ Killed remaining enx-api processes" || true
        
        if [ $STOPPED -eq 0 ]; then
          echo "‚ö†Ô∏è  No PID files found. Server may not be running in background."
        fi

  restart:

  status:
    desc: Check API server status
    vars:
      PID_FILE: '{{.APP_NAME}}.pid'
      LOG_FILE: '{{.APP_NAME}}.log'
    cmds:
      - |
        if [ ! -f {{.PID_FILE}} ]; then
          echo "{{.APP_NAME}} is not running in background"
          exit 0
        fi
        PID=$(cat {{.PID_FILE}})
        if kill -0 $PID 2>/dev/null; then
          echo "{{.APP_NAME}} is running (PID: $PID)"
          if [ -f {{.LOG_FILE}} ]; then
            echo ""
            echo "Last 10 lines of log:"
            tail -n 10 {{.LOG_FILE}}
          fi
        else
          echo "{{.APP_NAME}} is not running (stale PID file)"
          rm -f {{.PID_FILE}}
        fi

  restart:
    desc: Restart API server (works only for background mode)
    cmds:
      - task: stop
      - task: start
        vars:
          MODE: bg

  dev-setup:
    desc: Setup development environment
    cmds:
      - task deps
      - task check-env
      - echo ""
      - echo "Development environment ready!"
      - echo "Run 'task run' to start the application"
      - echo "Run 'task dev' for hot reload mode"

  ci-build:
    desc: Build for CI/CD
    cmds:
      - task deps
      - task test
      - task build

  check:
    desc: Run all checks (fmt, vet, lint, test)
    cmds:
      - task fmt
      - task vet
      - task test
      - echo "All checks passed!"

  # ===========================================
  # Container Image Build Tasks
  # ===========================================

  container-build:
    desc: Build container image with nerdctl (auto-detected version)
    vars:
      IMAGE_NAME: '{{.IMAGE_NAME | default .APP_NAME}}'
      IMAGE_TAG: '{{.IMAGE_TAG | default .VERSION}}'
    cmds:
      - echo "Building container image with version information"
      - echo "  Version {{.VERSION}}"
      - echo "  Git Commit {{.GIT_COMMIT}}"
      - echo "  Git Branch {{.GIT_BRANCH}}"
      - echo "  Build Time {{.BUILD_TIME}}"
      - echo "  Image {{.IMAGE_NAME}}:{{.IMAGE_TAG}}"
      - |
        nerdctl build \
          --build-arg VERSION="{{.VERSION}}" \
          --build-arg GIT_COMMIT="{{.GIT_COMMIT}}" \
          --build-arg GIT_BRANCH="{{.GIT_BRANCH}}" \
          --build-arg BUILD_TIME="{{.BUILD_TIME}}" \
          -f Dockerfile.version \
          -t "{{.IMAGE_NAME}}:{{.IMAGE_TAG}}" \
          .
      - echo "Container build completed successfully!"
      - echo "Run with nerdctl run -p 8090:8090 {{.IMAGE_NAME}}:{{.IMAGE_TAG}}"

  container-build-version:
    desc: Build container image with specific version (usage - task container-build-version VERSION=1.0.0)
    vars:
      IMAGE_NAME: '{{.IMAGE_NAME | default .APP_NAME}}'
      CUSTOM_VERSION: '{{.VERSION}}'
    cmds:
      - echo "Building container image with version {{.CUSTOM_VERSION}}"
      - echo "  Git Commit {{.GIT_COMMIT}}"
      - echo "  Git Branch {{.GIT_BRANCH}}"
      - echo "  Build Time {{.BUILD_TIME}}"
      - echo "  Image {{.IMAGE_NAME}}:{{.CUSTOM_VERSION}}"
      - |
        nerdctl build \
          --build-arg VERSION="{{.CUSTOM_VERSION}}" \
          --build-arg GIT_COMMIT="{{.GIT_COMMIT}}" \
          --build-arg GIT_BRANCH="{{.GIT_BRANCH}}" \
          --build-arg BUILD_TIME="{{.BUILD_TIME}}" \
          -f Dockerfile.version \
          -t "{{.IMAGE_NAME}}:{{.CUSTOM_VERSION}}" \
          .
      - |
        if [ "{{.CUSTOM_VERSION}}" != "dev" ]; then
          echo "Tagging as latest..."
          nerdctl tag "{{.IMAGE_NAME}}:{{.CUSTOM_VERSION}}" "{{.IMAGE_NAME}}:latest"
        fi
      - echo "Container build completed!"

  container-build-latest:
    desc: Build container image and tag as latest
    vars:
      IMAGE_NAME: '{{.IMAGE_NAME | default .APP_NAME}}'
      IMAGE_TAG: '{{.IMAGE_TAG | default .VERSION}}'
    cmds:
      - task: container-build
      - echo "Tagging as latest..."
      - nerdctl tag "{{.IMAGE_NAME}}:{{.IMAGE_TAG}}" "{{.IMAGE_NAME}}:latest"
      - echo "Tagged {{.IMAGE_NAME}}:latest"

  container-run:
    desc: Run container with nerdctl
    vars:
      IMAGE_NAME: '{{.IMAGE_NAME | default .APP_NAME}}'
      IMAGE_TAG: '{{.IMAGE_TAG | default .VERSION}}'
      PORT: '{{.PORT | default "8090"}}'
    cmds:
      - echo "Starting container {{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
      - nerdctl run -p {{.PORT}}:8090 "{{.IMAGE_NAME}}:{{.IMAGE_TAG}}"

  container-push:
    desc: Push container image to registry (usage - task container-push REGISTRY=your-registry.com)
    vars:
      IMAGE_NAME: '{{.IMAGE_NAME | default .APP_NAME}}'
      IMAGE_TAG: '{{.IMAGE_TAG | default .VERSION}}'
      REGISTRY: '{{.REGISTRY}}'
    cmds:
      - |
        if [ -z "{{.REGISTRY}}" ]; then
          echo "Error: REGISTRY is required"
          echo "Usage: task container-push REGISTRY=your-registry.com"
          exit 1
        fi
      - echo "Tagging for registry {{.REGISTRY}}..."
      - nerdctl tag "{{.IMAGE_NAME}}:{{.IMAGE_TAG}}" "{{.REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}"
      - echo "Pushing to {{.REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
      - nerdctl push "{{.REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}"
      - echo "Push completed!"

  container-clean:
    desc: Remove container image
    vars:
      IMAGE_NAME: '{{.IMAGE_NAME | default .APP_NAME}}'
      IMAGE_TAG: '{{.IMAGE_TAG | default .VERSION}}'
    cmds:
      - echo "Removing container image {{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
      - nerdctl rmi "{{.IMAGE_NAME}}:{{.IMAGE_TAG}}" || true
      - echo "Cleanup completed!"
